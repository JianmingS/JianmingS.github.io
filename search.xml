<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode 53. 最大子序和</title>
    <url>/2021/04/10/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>定义f(i)：以第i个数结尾的连续子数组的最大和<br>答案即为：max(f(i)), 0&lt;=i&lt;n</p>
<p>f(i) = max(f(i-1)+num[i], num[i])</p>
<p>时间复杂度：O(n), 空间复杂度：O(1)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        pre_max_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre_max_sum = <span class="built_in">max</span>(pre_max_sum + num, num)</span><br><span class="line">            ans = <span class="built_in">max</span>(pre_max_sum, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 3. 无重复字符的最长子串</title>
    <url>/2021/04/10/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>滑动窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        visited_char_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">            end = <span class="built_in">max</span>(end, start)</span><br><span class="line">            visited_char_set.add(s[start])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> end + <span class="number">1</span> &lt; s_len <span class="keyword">and</span> s[end + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> visited_char_set:</span><br><span class="line">                visited_char_set.add(s[end + <span class="number">1</span>])</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            visited_char_set.remove(s[start])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
        <tag>【算法】双指针</tag>
        <tag>【算法】滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 5. 最长回文子串</title>
    <url>/2021/04/09/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>中心扩展法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            s1 = self.get_palindrome(s, i, i)</span><br><span class="line">            s2 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(ret):</span><br><span class="line">                ret = s1</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s2) &gt; <span class="built_in">len</span>(ret):</span><br><span class="line">                ret = s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span>(<span class="params">self, s, left_index, right_index</span>):</span></span><br><span class="line">        ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left_index &gt;= <span class="number">0</span> <span class="keyword">and</span> right_index &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left_index] == s[right_index]:</span><br><span class="line">            ret = s[left_index: right_index + <span class="number">1</span>]</span><br><span class="line">            left_index -= <span class="number">1</span></span><br><span class="line">            right_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1448. 统计二叉树中好节点的数目</title>
    <url>/2021/04/11/leetcode-1448-%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<p>遍历二叉树即可</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.good_node_cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.good_node_cnt = <span class="number">0</span></span><br><span class="line">        self.solve_good_node_cnt(root, <span class="built_in">float</span>(<span class="string">&#x27;-INF&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.good_node_cnt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve_good_node_cnt</span>(<span class="params">self, root, max_val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= max_val:</span><br><span class="line">            self.good_node_cnt += <span class="number">1</span></span><br><span class="line">            max_val = root.val</span><br><span class="line">            </span><br><span class="line">        self.solve_good_node_cnt(root.left, max_val)</span><br><span class="line">        self.solve_good_node_cnt(root.right, max_val)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】递归</tag>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1. 两数之和</title>
    <url>/2021/04/11/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>遍历数组即可</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num_to_index = <span class="built_in">dict</span>([(num, i) <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)])</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            expected_num_index = num_to_index.get(target-num)</span><br><span class="line">            <span class="keyword">if</span> expected_num_index <span class="keyword">and</span> expected_num_index &gt; i:</span><br><span class="line">                <span class="keyword">return</span> [i, expected_num_index]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 560. 和为K的子数组</title>
    <url>/2021/04/11/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="定义pre-i"><a href="#定义pre-i" class="headerlink" title="定义pre[i]"></a>定义pre[i]</h2><p>下标[0, i]的子数组和</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>下标[j, i]的子数组和为k &lt;=&gt; pre[i]-pre[j-1] == k &lt;==&gt; pre[j-1] == pre[i]-k  (注意：j &lt;= i）<br>通过计算第i个元素前，有多少个pre等于pre[i]-k，可得到以第i个元素结尾的和为k的子数组个数<br>遍历n个元素，累加和为k的子数组个数，即可得到答案</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line">        pre_val_to_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        pre_val_to_cnt[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            ret += pre_val_to_cnt.get(pre_sum - k) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">            pre_val_to_cnt[pre_sum] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 523. 连续的子数组和</title>
    <url>/2021/04/13/leetcode-523-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="定义pre-i"><a href="#定义pre-i" class="headerlink" title="定义pre[i]"></a>定义pre[i]</h2><p>下标[0, i]的子数组和</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>下标[j, i]的子数组和为k的倍数 (j&lt;i)<br>&lt;=&gt;<br>pre[i]-pre[j-1] == n*k<br>&lt;==&gt;<br>pre[i] == n1*k + rem1<br>pre[j] == n2*k + rem2<br>rem1 == rem2<br>&lt;==&gt;<br>通过计算第i个元素前，是否有pre%k等于pre[i]%k，即说明存在以i结尾的子数组和为k的倍数</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(min(n,k))</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        rem_to_index = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;  <span class="comment"># 确保[0, i]子数组和是k的倍数时，返回true（i&gt;=2）</span></span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            rem = pre_sum%k</span><br><span class="line">            equal_rem_pos = rem_to_index.get(rem)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> equal_rem_pos <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                rem_to_index[rem] = i</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i - equal_rem_pos &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
        <tag>【算法】数学</tag>
        <tag>【算法】取余</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 236. 二叉树的最近公共祖先</title>
    <url>/2021/04/14/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>获取每个节点的父节点<br>记录p所有的祖先节点<br>q节点不断向祖先移动，若有祖先在p的祖先节点中，则该祖先为p、q的最近公共祖先</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.node_to_father = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        self.node_to_father = <span class="built_in">dict</span>()</span><br><span class="line">        self.traverse_tree(root)</span><br><span class="line"></span><br><span class="line">        visited_node_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            visited_node_set.add(p.val)</span><br><span class="line">            p = self.node_to_father.get(p.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val <span class="keyword">in</span> visited_node_set:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = self.node_to_father.get(q.val)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse_tree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.node_to_father[root.left.val] = root</span><br><span class="line">            self.traverse_tree(root.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.node_to_father[root.right.val] = root</span><br><span class="line">            self.traverse_tree(root.right)</span><br></pre></td></tr></table></figure>

<h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>两种情况：<br>1、p不是q的祖先节点（反之亦然）<br>从root结点开始遍历节点，若存在节点，p（或q）在其左子树找到  且  q（或p）在其右子树找到，则该节点就是p、q的最近公共祖先<br>2、p是q的祖先节点（反之亦然）<br>从root结点开始遍历节点，若存在节点等于p（或q），则该节点就是p、q的最近公共祖先</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val == root.val <span class="keyword">or</span> q.val == root.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 325. 和等于 k 的最长子数组长度</title>
    <url>/2021/04/14/leetcode-325-%E5%92%8C%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>方法同 <a href="https://jianmings.github.io/2021/04/11/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" target="_blank">leetcode 560. 和为K的子数组</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArrayLen</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        pre_sum_to_index = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            expected_val = pre_sum - k</span><br><span class="line">            <span class="keyword">if</span> expected_val <span class="keyword">in</span> pre_sum_to_index:</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i - pre_sum_to_index[expected_val])</span><br><span class="line">            <span class="keyword">if</span> pre_sum <span class="keyword">not</span> <span class="keyword">in</span> pre_sum_to_index:</span><br><span class="line">                pre_sum_to_index[pre_sum] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1650. 二叉树的最近公共祖先 III</title>
    <url>/2021/04/15/leetcode-1650-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-III/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>同 <a href="https://jianmings.github.io/2021/04/14/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" target="_blank">leetcode 236. 二叉树的最近公共祖先</a> 方法1</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = None</span></span><br><span class="line"><span class="string">        self.right = None</span></span><br><span class="line"><span class="string">        self.parent = None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, p: <span class="string">&#x27;Node&#x27;</span>, q: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        p_parent_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p_parent_set.add(p.val)</span><br><span class="line">            p = p.parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val <span class="keyword">in</span> p_parent_set:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = q.parent</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 121. 买卖股票的最佳时机</title>
    <url>/2021/04/15/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>遍历一次数组即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        min_val = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_val = <span class="built_in">min</span>(min_val, price)</span><br><span class="line">            profit = price - min_val</span><br><span class="line">            <span class="keyword">if</span> profit &gt; ret:</span><br><span class="line">                ret = profit</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 41. 缺失的第一个正数</title>
    <url>/2021/04/17/leetcode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于一个长度为N的数组，缺失的第一个正数在[1, N+1]中（若[1,N]在数组都出现了，那么答案是N+1），否则答案是[1,N]中没有出现的最小正数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums_len + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            num = <span class="built_in">abs</span>(num)</span><br><span class="line">            <span class="keyword">if</span> num &lt;= nums_len:</span><br><span class="line">                nums[num-<span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums_len + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 54. 螺旋矩阵</title>
    <url>/2021/04/22/leetcode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>模拟</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(mn)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(mn)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ret = []</span><br><span class="line">        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row = <span class="built_in">len</span>(matrix)</span><br><span class="line">        visited = [[<span class="literal">False</span>]*col <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        direct = <span class="string">&#x27;right&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> x &gt;= row <span class="keyword">or</span> y &gt;= col <span class="keyword">or</span> visited[x][y]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            ret.append(matrix[x][y])</span><br><span class="line">            visited[x][y] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> y == col - <span class="number">1</span> <span class="keyword">or</span> visited[x][y+<span class="number">1</span>]:</span><br><span class="line">                    direct = <span class="string">&#x27;down&#x27;</span></span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;down&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> x == row - <span class="number">1</span> <span class="keyword">or</span> visited[x+<span class="number">1</span>][y]:</span><br><span class="line">                    direct = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">                    y -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> y == <span class="number">0</span> <span class="keyword">or</span> visited[x][y-<span class="number">1</span>]:</span><br><span class="line">                    direct = <span class="string">&#x27;up&#x27;</span></span><br><span class="line">                    x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;up&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> visited[x-<span class="number">1</span>][y]:</span><br><span class="line">                    direct = <span class="string">&#x27;right&#x27;</span></span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 49. 字母异位词分组</title>
    <url>/2021/04/23/leetcode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序后相等的字符串，划归为一组</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n*mlogm)  （n：字符串个数；m：字符串长度）</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(n*m)  （n：字符串个数；m：字符串长度）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        flag_to_list = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            flag_to_list[<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))].append(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(flag_to_list.values())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 15. 三数之和</title>
    <url>/2021/05/09/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用双指针将时间复杂度从O(N^3)降为O(N^2)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(N^2)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(N)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_len &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">            </span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> num == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = nums_len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = num + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    ret.append([num, nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left+<span class="number">1</span>] == nums[left]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right-<span class="number">1</span>] == nums[right]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>【工厂模式】工厂方法</title>
    <url>/2021/05/21/%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>创建对象的代码在许多不同的地方，导致难以跟踪应用中创建的对象</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>基于单一的函数创建对象：根据传入参数，创建出想要的对象。<br>（外部不需要知道对象的实现细节）</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="背景-amp-amp-需求"><a href="#背景-amp-amp-需求" class="headerlink" title="背景&amp;&amp;需求"></a>背景&amp;&amp;需求</h2><p>XXX数据存储于XML文件和JSON文件中，目前需要获取XXX数据</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> etree</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONDataExtractor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">        self.data = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.data = json.load(f)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parsed_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLDataExtractor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">        self.tree = etree.parse(file_path)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parsed_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_extractor_factory</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> file_path.endswith(<span class="string">&#x27;json&#x27;</span>):</span><br><span class="line">        extractor = JSONDataExtractor</span><br><span class="line">    <span class="keyword">elif</span> file_path.endswith(<span class="string">&#x27;xml&#x27;</span>):</span><br><span class="line">        extractor = XMLDataExtractor</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Cannot extract data from <span class="subst">&#123;file_path&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> extractor(file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_data</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    factory_obj = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        factory_obj = data_extractor_factory(file_path)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">return</span> factory_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root_path = <span class="string">&#x27;/20210523&#x27;</span></span><br><span class="line">    <span class="comment"># 获取存储在json中的数据</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.json&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;JSON Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存储在xml中的数据</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.xml&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;XML Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存储在ini中的数据，会报异常</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.ini&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Abnormal Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>JSON Data=[{‘title’: ‘Ha’}]</p>
<p>XML Data=&lt;xml.etree.ElementTree.ElementTree object at 0x7fcd15d79a60&gt;</p>
<p>Cannot extract data from 20210523/test.ini<br>Abnormal Data=None</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1822. 数组元素积的符号</title>
    <url>/2021/05/26/leetcode-1822-%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%A7%AF%E7%9A%84%E7%AC%A6%E5%8F%B7/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>数组中存在0，结果为0。否则，奇数个负数，结果为-1；偶数个负数结果为1</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(1)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arraySign</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        sign = <span class="number">1</span></span><br><span class="line">        is_zero = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            <span class="keyword">if</span> num == <span class="number">0</span>:</span><br><span class="line">                is_zero = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> num &lt; <span class="number">0</span>:</span><br><span class="line">                sign *= -<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> is_zero <span class="keyword">and</span> sign <span class="keyword">or</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数学</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 297. 二叉树的序列化与反序列化</title>
    <url>/2021/05/29/leetcode-297-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    <content><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>前序遍历 序列化 二叉树 为 字符串<br>前序遍历 反序列化 字符串 为 二叉树<br>注意叶子节点的处理</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n)   n为节点数</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(n)   n为节点数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode(object):</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">serialize</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Encodes a tree to a single string.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type root: TreeNode</span></span><br><span class="line"><span class="string">        :rtype: str</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;None&#x27;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&#x27;<span class="subst">&#123;root.val&#125;</span>,<span class="subst">&#123;self.serialize(root.left)&#125;</span>,<span class="subst">&#123;self.serialize(root.right)&#125;</span>&#x27;</span></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">deserialize</span>(<span class="params">self, data</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;Decodes your encoded data to tree.</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        :type data: str</span></span><br><span class="line"><span class="string">        :rtype: TreeNode</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">build_tree</span>(<span class="params">node_list</span>):</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> node_list:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">            node = node_list.pop(<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">if</span> node == <span class="string">&#x27;None&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                </span><br><span class="line">            root = TreeNode(node)</span><br><span class="line">            root.left = build_tree(node_list)</span><br><span class="line">            root.right = build_tree(node_list)</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> build_tree(data.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line"><span class="comment"># Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"># ser = Codec()</span></span><br><span class="line"><span class="comment"># deser = Codec()</span></span><br><span class="line"><span class="comment"># ans = deser.deserialize(ser.serialize(root))</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>【工厂模式】抽象工厂</title>
    <url>/2021/05/30/%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>一个对象的创建，依赖于多个不同的工厂方法，如何使这个对象的创建更容易呢？</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>将多个工厂方法组合在一起，作为一个抽象工厂</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="背景-amp-amp-需求"><a href="#背景-amp-amp-需求" class="headerlink" title="背景&amp;&amp;需求"></a>背景&amp;&amp;需求</h2><p>根据用户年龄，决定玩儿童游戏（青蛙吃虫子），还是成人游戏（巫师对抗怪物）</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Frog</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interact_with</span>(<span class="params">self, obstacle</span>):</span></span><br><span class="line">        act = obstacle.action()</span><br><span class="line">        msg = <span class="string">f&#x27;<span class="subst">&#123;self&#125;</span> the Frog encounters <span class="subst">&#123;obstacle&#125;</span> and <span class="subst">&#123;act&#125;</span>!&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bug</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;a bug&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;eats it&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂（创建青蛙、虫子）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FrogWorld</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        self.player_name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;------ Frog World ------&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_character</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Frog(self.player_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_obstacle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Bug()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wizard</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">interact_with</span>(<span class="params">self, obstacle</span>):</span></span><br><span class="line">        act = obstacle.action()</span><br><span class="line">        msg = <span class="string">f&#x27;<span class="subst">&#123;self&#125;</span> the Wizard battles against <span class="subst">&#123;obstacle&#125;</span> and <span class="subst">&#123;act&#125;</span>!&#x27;</span></span><br><span class="line">        <span class="built_in">print</span>(msg)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ork</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;an evil ork&#x27;</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;kills it&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 抽象工厂（创建巫师、怪物）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WizardWorld</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="built_in">print</span>(self)</span><br><span class="line">        self.player_name = name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;------ Wizard World ------&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_character</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Wizard(self.player_name)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 工厂方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">make_obstacle</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Ork()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, factory</span>):</span></span><br><span class="line">        self.hero = factory.make_character()</span><br><span class="line">        self.obstacle = factory.make_obstacle()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.hero.interact_with(self.obstacle)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    name = <span class="string">&#x27;user&#x27;</span></span><br><span class="line">    age = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;please input age: &#x27;</span>))</span><br><span class="line">    game = age &lt; <span class="number">18</span> <span class="keyword">and</span> FrogWorld <span class="keyword">or</span> WizardWorld</span><br><span class="line">    Game(game(name)).play()</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><blockquote>
<p>please input age: 18<br>—— Wizard World ——<br>user the Wizard battles against an evil ork and kills it!</p>
</blockquote>
<blockquote>
<p>please input age: 10<br>—— Frog World ——<br>user the Frog encounters a bug and eats it!</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 56. 合并区间</title>
    <url>/2021/06/03/leetcode-56-%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>遍历数组，比较元素区间即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span>(<span class="params">self, intervals: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ret = []</span><br><span class="line">        new_intervals = <span class="built_in">sorted</span>(intervals, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line">        left, right = new_intervals[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> a, b <span class="keyword">in</span> new_intervals[<span class="number">1</span>:]:</span><br><span class="line">            <span class="keyword">if</span> right &gt;= b:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> right &gt;= a:</span><br><span class="line">                right = b</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret.append([left, right])</span><br><span class="line">                left = a</span><br><span class="line">                right = b</span><br><span class="line">        </span><br><span class="line">        ret.append([left, right])</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 62. 不同路径</title>
    <url>/2021/06/05/leetcode-62-%E4%B8%8D%E5%90%8C%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>定义状态：<br>dp[i][j] := 从 (0, 0) 走到 (i, j) 不同的路径数目</p>
<p>动态规划转移方程：<br>dp[i][j] = dp[i][j-1] + dp[i-1][j]</p>
<p>状态压缩：<br>dp[j] += dp[j-1]</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span>(<span class="params">self, m: <span class="built_in">int</span>, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        dp = [<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> <span class="built_in">range</span>(m):</span><br><span class="line">            <span class="keyword">for</span> col <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">                <span class="keyword">if</span> col == <span class="number">0</span>:</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                dp[col] += dp[col-<span class="number">1</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>]</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 98. 验证二叉搜索树</title>
    <url>/2021/06/05/leetcode-98-%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>判断每个节点的值是否在 (l, r) 范围内 （开区间）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.solve(root)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve</span>(<span class="params">self, root, lower=-<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;INF&#x27;</span></span>), upper=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;INF&#x27;</span></span>)</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> (lower &lt; root.val &lt; upper):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.solve(root.left, lower, root.val):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.solve(root.right, root.val, upper):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 277. 搜寻名人</title>
    <url>/2021/06/14/leetcode-277-%E6%90%9C%E5%AF%BB%E5%90%8D%E4%BA%BA/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>“名人” 定义：<br>其他所有 n - 1 个人都认识他/她，而他/她并不认识其他任何人</p>
<p>若a不认识b  =&gt; b一定不是名人，a可能是名人<br>若a认识c   =&gt;  a一定不是名人，c可能不是名人</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># The knows API is already defined for you.</span></span><br><span class="line"><span class="comment"># return a bool, whether a knows b</span></span><br><span class="line"><span class="comment"># def knows(a: int, b: int) -&gt; bool:</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findCelebrity</span>(<span class="params">self, n: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        candidate = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> knows(candidate, i):</span><br><span class="line">                candidate = i</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(candidate):</span><br><span class="line">            <span class="keyword">if</span> knows(candidate, i) <span class="keyword">or</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(candidate+<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> knows(i, candidate):</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> candidate</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
</search>
