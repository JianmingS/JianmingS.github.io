<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2021/04/04/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>leetcode 53. 最大子序和</title>
    <url>/2021/04/10/leetcode-53-%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>定义f(i)：以第i个数结尾的连续子数组的最大和<br>答案即为：max(f(i)), 0&lt;=i&lt;n</p>
<p>f(i) = max(f(i-1)+num[i], num[i])</p>
<p>时间复杂度：O(n), 空间复杂度：O(1)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArray</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ans = nums[<span class="number">0</span>]</span><br><span class="line">        pre_max_sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            pre_max_sum = <span class="built_in">max</span>(pre_max_sum + num, num)</span><br><span class="line">            ans = <span class="built_in">max</span>(pre_max_sum, ans)</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 3. 无重复字符的最长子串</title>
    <url>/2021/04/10/leetcode-3-%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>滑动窗口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lengthOfLongestSubstring</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        s_len = <span class="built_in">len</span>(s)</span><br><span class="line">        ans = <span class="number">0</span></span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        end = <span class="number">0</span></span><br><span class="line">        visited_char_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(s_len):</span><br><span class="line">            end = <span class="built_in">max</span>(end, start)</span><br><span class="line">            visited_char_set.add(s[start])</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> end + <span class="number">1</span> &lt; s_len <span class="keyword">and</span> s[end + <span class="number">1</span>] <span class="keyword">not</span> <span class="keyword">in</span> visited_char_set:</span><br><span class="line">                visited_char_set.add(s[end + <span class="number">1</span>])</span><br><span class="line">                end += <span class="number">1</span></span><br><span class="line">            ans = <span class="built_in">max</span>(ans, end - start + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">            visited_char_set.remove(s[start])</span><br><span class="line">        <span class="keyword">return</span> ans</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
        <tag>【算法】双指针</tag>
        <tag>【算法】滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 5. 最长回文子串</title>
    <url>/2021/04/09/leetcode-5-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
    <content><![CDATA[<p>中心扩展法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">longestPalindrome</span>(<span class="params">self, s: <span class="built_in">str</span></span>) -&gt; <span class="built_in">str</span>:</span></span><br><span class="line">        ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(s)):</span><br><span class="line">            s1 = self.get_palindrome(s, i, i)</span><br><span class="line">            s2 = self.get_palindrome(s, i, i+<span class="number">1</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s1) &gt; <span class="built_in">len</span>(ret):</span><br><span class="line">                ret = s1</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(s2) &gt; <span class="built_in">len</span>(ret):</span><br><span class="line">                ret = s2</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_palindrome</span>(<span class="params">self, s, left_index, right_index</span>):</span></span><br><span class="line">        ret = <span class="string">&#x27;&#x27;</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span> left_index &gt;= <span class="number">0</span> <span class="keyword">and</span> right_index &lt; <span class="built_in">len</span>(s) <span class="keyword">and</span> s[left_index] == s[right_index]:</span><br><span class="line">            ret = s[left_index: right_index + <span class="number">1</span>]</span><br><span class="line">            left_index -= <span class="number">1</span></span><br><span class="line">            right_index += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1448. 统计二叉树中好节点的数目</title>
    <url>/2021/04/11/leetcode-1448-%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%A5%BD%E8%8A%82%E7%82%B9%E7%9A%84%E6%95%B0%E7%9B%AE/</url>
    <content><![CDATA[<p>遍历二叉树即可</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(1)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, val=0, left=None, right=None):</span></span><br><span class="line"><span class="comment">#         self.val = val</span></span><br><span class="line"><span class="comment">#         self.left = left</span></span><br><span class="line"><span class="comment">#         self.right = right</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span></span><br><span class="line">        self.good_node_cnt = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">goodNodes</span>(<span class="params">self, root: TreeNode</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        self.good_node_cnt = <span class="number">0</span></span><br><span class="line">        self.solve_good_node_cnt(root, <span class="built_in">float</span>(<span class="string">&#x27;-INF&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> self.good_node_cnt</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">solve_good_node_cnt</span>(<span class="params">self, root, max_val</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> root.val &gt;= max_val:</span><br><span class="line">            self.good_node_cnt += <span class="number">1</span></span><br><span class="line">            max_val = root.val</span><br><span class="line">            </span><br><span class="line">        self.solve_good_node_cnt(root.left, max_val)</span><br><span class="line">        self.solve_good_node_cnt(root.right, max_val)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】递归</tag>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1. 两数之和</title>
    <url>/2021/04/11/leetcode-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<p>遍历数组即可</p>
<p>时间复杂度：O(n)<br>空间复杂度：O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">twoSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], target: <span class="built_in">int</span></span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        num_to_index = <span class="built_in">dict</span>([(num, i) <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums)])</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            expected_num_index = num_to_index.get(target-num)</span><br><span class="line">            <span class="keyword">if</span> expected_num_index <span class="keyword">and</span> expected_num_index &gt; i:</span><br><span class="line">                <span class="keyword">return</span> [i, expected_num_index]</span><br><span class="line">        <span class="keyword">return</span> []</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 560. 和为K的子数组</title>
    <url>/2021/04/11/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="定义pre-i"><a href="#定义pre-i" class="headerlink" title="定义pre[i]"></a>定义pre[i]</h2><p>下标[0, i]的子数组和</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>下标[j, i]的子数组和为k &lt;=&gt; pre[i]-pre[j-1] == k &lt;==&gt; pre[j-1] == pre[i]-k  (注意：j &lt;= i）<br>通过计算第i个元素前，有多少个pre等于pre[i]-k，可得到以第i个元素结尾的和为k的子数组个数<br>遍历n个元素，累加和为k的子数组个数，即可得到答案</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line">        pre_val_to_cnt = defaultdict(<span class="built_in">int</span>)</span><br><span class="line">        pre_val_to_cnt[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            ret += pre_val_to_cnt.get(pre_sum - k) <span class="keyword">or</span> <span class="number">0</span></span><br><span class="line">            pre_val_to_cnt[pre_sum] += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 523. 连续的子数组和</title>
    <url>/2021/04/13/leetcode-523-%E8%BF%9E%E7%BB%AD%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><h2 id="定义pre-i"><a href="#定义pre-i" class="headerlink" title="定义pre[i]"></a>定义pre[i]</h2><p>下标[0, i]的子数组和</p>
<h2 id="求解方法"><a href="#求解方法" class="headerlink" title="求解方法"></a>求解方法</h2><p>下标[j, i]的子数组和为k的倍数 (j&lt;i)<br>&lt;=&gt;<br>pre[i]-pre[j-1] == n*k<br>&lt;==&gt;<br>pre[i] == n1*k + rem1<br>pre[j] == n2*k + rem2<br>rem1 == rem2<br>&lt;==&gt;<br>通过计算第i个元素前，是否有pre%k等于pre[i]%k，即说明存在以i结尾的子数组和为k的倍数</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(min(n,k))</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">checkSubarraySum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">bool</span>:</span></span><br><span class="line">        rem_to_index = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;  <span class="comment"># 确保[0, i]子数组和是k的倍数时，返回true（i&gt;=2）</span></span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            rem = pre_sum%k</span><br><span class="line">            equal_rem_pos = rem_to_index.get(rem)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> equal_rem_pos <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                rem_to_index[rem] = i</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> i - equal_rem_pos &gt;= <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
        <tag>【算法】数学</tag>
        <tag>【算法】取余</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 236. 二叉树的最近公共祖先</title>
    <url>/2021/04/14/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>获取每个节点的父节点<br>记录p所有的祖先节点<br>q节点不断向祖先移动，若有祖先在p的祖先节点中，则该祖先为p、q的最近公共祖先</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.node_to_father = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        self.node_to_father = <span class="built_in">dict</span>()</span><br><span class="line">        self.traverse_tree(root)</span><br><span class="line"></span><br><span class="line">        visited_node_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            visited_node_set.add(p.val)</span><br><span class="line">            p = self.node_to_father.get(p.val)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val <span class="keyword">in</span> visited_node_set:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = self.node_to_father.get(q.val)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">traverse_tree</span>(<span class="params">self, root</span>):</span></span><br><span class="line">        <span class="keyword">if</span> root.left:</span><br><span class="line">            self.node_to_father[root.left.val] = root</span><br><span class="line">            self.traverse_tree(root.left)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> root.right:</span><br><span class="line">            self.node_to_father[root.right.val] = root</span><br><span class="line">            self.traverse_tree(root.right)</span><br></pre></td></tr></table></figure>

<h1 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h1><h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h2><p>两种情况：<br>1、p不是q的祖先节点（反之亦然）<br>从root结点开始遍历节点，若存在节点，p（或q）在其左子树找到  且  q（或p）在其右子树找到，则该节点就是p、q的最近公共祖先<br>2、p是q的祖先节点（反之亦然）<br>从root结点开始遍历节点，若存在节点等于p（或q），则该节点就是p、q的最近公共祖先</p>
<h2 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>O(n)</p>
<h2 id="空间复杂度-1"><a href="#空间复杂度-1" class="headerlink" title="空间复杂度"></a>空间复杂度</h2><p>O(n)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"># class TreeNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.left = None</span></span><br><span class="line"><span class="comment">#         self.right = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, root: <span class="string">&#x27;TreeNode&#x27;</span>, p: <span class="string">&#x27;TreeNode&#x27;</span>, q: <span class="string">&#x27;TreeNode&#x27;</span></span>) -&gt; &#x27;TreeNode&#x27;:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> p.val == root.val <span class="keyword">or</span> q.val == root.val:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        </span><br><span class="line">        left = self.lowestCommonAncestor(root.left, p, q)</span><br><span class="line">        right = self.lowestCommonAncestor(root.right, p, q)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> left <span class="keyword">and</span> right:</span><br><span class="line">            <span class="keyword">return</span> root</span><br><span class="line">        <span class="keyword">if</span> left:</span><br><span class="line">            <span class="keyword">return</span> left</span><br><span class="line">        <span class="keyword">if</span> right:</span><br><span class="line">            <span class="keyword">return</span> right</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 325. 和等于 k 的最长子数组长度</title>
    <url>/2021/04/14/leetcode-325-%E5%92%8C%E7%AD%89%E4%BA%8E-k-%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>方法同 <a href="https://jianmings.github.io/2021/04/11/leetcode-560-%E5%92%8C%E4%B8%BAK%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" target="_blank">leetcode 560. 和为K的子数组</a></p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxSubArrayLen</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>], k: <span class="built_in">int</span></span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        pre_sum_to_index = &#123;<span class="number">0</span>: -<span class="number">1</span>&#125;</span><br><span class="line">        pre_sum = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            pre_sum += num</span><br><span class="line">            expected_val = pre_sum - k</span><br><span class="line">            <span class="keyword">if</span> expected_val <span class="keyword">in</span> pre_sum_to_index:</span><br><span class="line">                ret = <span class="built_in">max</span>(ret, i - pre_sum_to_index[expected_val])</span><br><span class="line">            <span class="keyword">if</span> pre_sum <span class="keyword">not</span> <span class="keyword">in</span> pre_sum_to_index:</span><br><span class="line">                pre_sum_to_index[pre_sum] = i</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】前缀和</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 1650. 二叉树的最近公共祖先 III</title>
    <url>/2021/04/15/leetcode-1650-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88-III/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>同 <a href="https://jianmings.github.io/2021/04/14/leetcode-236-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/" target="_blank">leetcode 236. 二叉树的最近公共祖先</a> 方法1</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># Definition for a Node.</span></span><br><span class="line"><span class="string">class Node:</span></span><br><span class="line"><span class="string">    def __init__(self, val):</span></span><br><span class="line"><span class="string">        self.val = val</span></span><br><span class="line"><span class="string">        self.left = None</span></span><br><span class="line"><span class="string">        self.right = None</span></span><br><span class="line"><span class="string">        self.parent = None</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">lowestCommonAncestor</span>(<span class="params">self, p: <span class="string">&#x27;Node&#x27;</span>, q: <span class="string">&#x27;Node&#x27;</span></span>) -&gt; &#x27;Node&#x27;:</span></span><br><span class="line">        p_parent_set = <span class="built_in">set</span>()</span><br><span class="line">        <span class="keyword">while</span> p:</span><br><span class="line">            p_parent_set.add(p.val)</span><br><span class="line">            p = p.parent</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> q:</span><br><span class="line">            <span class="keyword">if</span> q.val <span class="keyword">in</span> p_parent_set:</span><br><span class="line">                <span class="keyword">return</span> q</span><br><span class="line">            q = q.parent</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 121. 买卖股票的最佳时机</title>
    <url>/2021/04/15/leetcode-121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>遍历一次数组即可</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">maxProfit</span>(<span class="params">self, prices: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        ret = <span class="number">0</span></span><br><span class="line">        min_val = <span class="built_in">float</span>(<span class="string">&#x27;INF&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> price <span class="keyword">in</span> prices:</span><br><span class="line">            min_val = <span class="built_in">min</span>(min_val, price)</span><br><span class="line">            profit = price - min_val</span><br><span class="line">            <span class="keyword">if</span> profit &gt; ret:</span><br><span class="line">                ret = profit</span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【数组】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 41. 缺失的第一个正数</title>
    <url>/2021/04/17/leetcode-41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>对于一个长度为N的数组，缺失的第一个正数在[1, N+1]中（若[1,N]在数组都出现了，那么答案是N+1），否则答案是[1,N]中没有出现的最小正数</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="built_in">int</span>:</span></span><br><span class="line">        nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">                nums[i] = nums_len + <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">            num = <span class="built_in">abs</span>(num)</span><br><span class="line">            <span class="keyword">if</span> num &lt;= nums_len:</span><br><span class="line">                nums[num-<span class="number">1</span>] = -<span class="built_in">abs</span>(nums[num-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> i + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> nums_len + <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 54. 螺旋矩阵</title>
    <url>/2021/04/22/leetcode-54-%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>模拟</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(mn)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(mn)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">spiralOrder</span>(<span class="params">self, matrix: <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]</span>) -&gt; <span class="type">List</span>[<span class="built_in">int</span>]:</span></span><br><span class="line">        ret = []</span><br><span class="line">        col = <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">        row = <span class="built_in">len</span>(matrix)</span><br><span class="line">        visited = [[<span class="literal">False</span>]*col <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(row)]</span><br><span class="line">        x = <span class="number">0</span></span><br><span class="line">        y = <span class="number">0</span></span><br><span class="line">        direct = <span class="string">&#x27;right&#x27;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> x &gt;= row <span class="keyword">or</span> y &gt;= col <span class="keyword">or</span> visited[x][y]:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            </span><br><span class="line">            ret.append(matrix[x][y])</span><br><span class="line">            visited[x][y] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;right&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> y == col - <span class="number">1</span> <span class="keyword">or</span> visited[x][y+<span class="number">1</span>]:</span><br><span class="line">                    direct = <span class="string">&#x27;down&#x27;</span></span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;down&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> x == row - <span class="number">1</span> <span class="keyword">or</span> visited[x+<span class="number">1</span>][y]:</span><br><span class="line">                    direct = <span class="string">&#x27;left&#x27;</span></span><br><span class="line">                    y -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x += <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;left&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> y == <span class="number">0</span> <span class="keyword">or</span> visited[x][y-<span class="number">1</span>]:</span><br><span class="line">                    direct = <span class="string">&#x27;up&#x27;</span></span><br><span class="line">                    x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    y -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> direct == <span class="string">&#x27;up&#x27;</span>:</span><br><span class="line">                <span class="keyword">if</span> x == <span class="number">0</span> <span class="keyword">or</span> visited[x-<span class="number">1</span>][y]:</span><br><span class="line">                    direct = <span class="string">&#x27;right&#x27;</span></span><br><span class="line">                    y += <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    x -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 49. 字母异位词分组</title>
    <url>/2021/04/23/leetcode-49-%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%E5%88%86%E7%BB%84/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>排序后相等的字符串，划归为一组</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(n*mlogm)  （n：字符串个数；m：字符串长度）</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(n*m)  （n：字符串个数；m：字符串长度）</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">groupAnagrams</span>(<span class="params">self, strs: <span class="type">List</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">str</span>]]:</span></span><br><span class="line">        flag_to_list = defaultdict(<span class="built_in">list</span>)</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> strs:</span><br><span class="line">            flag_to_list[<span class="string">&#x27;&#x27;</span>.join(<span class="built_in">sorted</span>(s))].append(s)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">list</span>(flag_to_list.values())</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode 15. 三数之和</title>
    <url>/2021/05/09/leetcode-15-%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/</url>
    <content><![CDATA[<h1 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h1><p>利用双指针将时间复杂度从O(N^3)降为O(N^2)</p>
<h1 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h1><p>O(N^2)</p>
<h1 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h1><p>O(N)</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">threeSum</span>(<span class="params">self, nums: <span class="type">List</span>[<span class="built_in">int</span>]</span>) -&gt; <span class="type">List</span>[<span class="type">List</span>[<span class="built_in">int</span>]]:</span></span><br><span class="line">        ret = []</span><br><span class="line"></span><br><span class="line">        nums_len = <span class="built_in">len</span>(nums)</span><br><span class="line">        <span class="keyword">if</span> nums_len &lt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">            </span><br><span class="line">        nums.sort()</span><br><span class="line">        <span class="keyword">for</span> i, num <span class="keyword">in</span> <span class="built_in">enumerate</span>(nums):</span><br><span class="line">            <span class="keyword">if</span> num &gt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> num == nums[i-<span class="number">1</span>]:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            left = i + <span class="number">1</span></span><br><span class="line">            right = nums_len - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> left &lt; right:</span><br><span class="line">                total = num + nums[left] + nums[right]</span><br><span class="line">                <span class="keyword">if</span> total == <span class="number">0</span>:</span><br><span class="line">                    ret.append([num, nums[left], nums[right]])</span><br><span class="line">                    <span class="keyword">while</span> left &lt; right <span class="keyword">and</span> nums[left+<span class="number">1</span>] == nums[left]:</span><br><span class="line">                        left += <span class="number">1</span></span><br><span class="line">                    <span class="keyword">while</span> right &gt; left <span class="keyword">and</span> nums[right-<span class="number">1</span>] == nums[right]:</span><br><span class="line">                        right -= <span class="number">1</span></span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> total &gt; <span class="number">0</span>:</span><br><span class="line">                    right -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    left += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> ret</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>【算法】数组</tag>
        <tag>【算法】双指针</tag>
      </tags>
  </entry>
  <entry>
    <title>【工厂模式】工厂方法</title>
    <url>/2021/05/21/%E3%80%90%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%91%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>创建对象的代码在许多不同的地方，导致难以跟踪应用中创建的对象</p>
<h1 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h1><p>基于单一的函数创建对象：根据传入参数，创建出想要的对象。<br>（外部不需要知道对象的实现细节）</p>
<h1 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h1><h2 id="背景-amp-amp-需求"><a href="#背景-amp-amp-需求" class="headerlink" title="背景&amp;&amp;需求"></a>背景&amp;&amp;需求</h2><p>XXX数据存储于XML文件和JSON文件中，目前需要获取XXX数据</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> xml.etree.ElementTree <span class="keyword">as</span> etree</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONDataExtractor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">        self.data = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, mode=<span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            self.data = json.load(f)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parsed_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">XMLDataExtractor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, file_path</span>):</span></span><br><span class="line">        self.tree = etree.parse(file_path)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parsed_data</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.tree</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">data_extractor_factory</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    <span class="keyword">if</span> file_path.endswith(<span class="string">&#x27;json&#x27;</span>):</span><br><span class="line">        extractor = JSONDataExtractor</span><br><span class="line">    <span class="keyword">elif</span> file_path.endswith(<span class="string">&#x27;xml&#x27;</span>):</span><br><span class="line">        extractor = XMLDataExtractor</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">f&#x27;Cannot extract data from <span class="subst">&#123;file_path&#125;</span>&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> extractor(file_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">extract_data</span>(<span class="params">file_path</span>):</span></span><br><span class="line">    factory_obj = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        factory_obj = data_extractor_factory(file_path)</span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">    <span class="keyword">return</span> factory_obj</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    root_path = <span class="string">&#x27;/Users/jianmingshi/Projects/Blog/source/static/20210523&#x27;</span></span><br><span class="line">    <span class="comment"># 获取存储在json中的数据</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.json&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;JSON Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存储在xml中的数据</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.xml&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;XML Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 获取存储在ini中的数据，会报异常</span></span><br><span class="line">    factory = extract_data(os.path.join(root_path, <span class="string">&#x27;test.ini&#x27;</span>))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&#x27;Abnormal Data=<span class="subst">&#123;factory <span class="keyword">and</span> factory.parsed_data&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>输出<br>![](static/20210523/截屏2021-05-23 20.20.45.png)</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>工厂模式</tag>
      </tags>
  </entry>
</search>
